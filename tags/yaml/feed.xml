<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YAML on Scott&#39;s Weblog</title>
    <link>https://www.howellyang.com/tags/yaml/</link>
    <description>Recent content in YAML on Scott&#39;s Weblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 May 2022 08:45:00 -0600</lastBuildDate><atom:link href="https://www.howellyang.com/tags/yaml/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Technology Short Take 155</title>
      <link>https://www.howellyang.com/2022/05/27/technology-short-take-155/</link>
      <pubDate>Fri, 27 May 2022 08:45:00 -0600</pubDate>
      
      <guid>https://www.howellyang.com/2022/05/27/technology-short-take-155/</guid>
      <description>&lt;p&gt;Welcome to Technology Short Take #155, just in time for the 2022 Memorial Day holiday weekend! (Here in the US, at least.) I mean, don&amp;rsquo;t you want to spend this weekend catching up on some technology-related articles instead of cooking on the grill and gathering with friends and family? I certainly hope not! Still, for those who need a little technology fix over the weekend, hopefully I&amp;rsquo;ve included something useful in the list of articles below. Enjoy!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using Test-Driven Development for Kustomize Overlays</title>
      <link>https://www.howellyang.com/2022/01/10/using-test-driven-development-for-kustomize-overlays/</link>
      <pubDate>Mon, 10 Jan 2022 09:00:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2022/01/10/using-test-driven-development-for-kustomize-overlays/</guid>
      <description>&lt;p&gt;I am by no means a developer (not by a long shot!), but I have been learning lots of development-related things over the last several years and trying to incorporate those into my workflows. One of these is the idea of &lt;em&gt;test-driven development&lt;/em&gt; (see &lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;Wikipedia&lt;/a&gt; for a definition and some additional information), in which one writes tests to validate functionality before writing the code to implement said functionality (pardon the paraphrasing). In this post, I&amp;rsquo;ll discuss how to use &lt;a href=&#34;https://www.conftest.dev/&#34;&gt;&lt;code&gt;conftest&lt;/code&gt;&lt;/a&gt; to (loosely) implement test-driven development for &lt;a href=&#34;https://kubernetes-sigs.github.io/kustomize/&#34;&gt;Kustomize&lt;/a&gt; overlays.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creating Reusable Kuma Installation YAML</title>
      <link>https://www.howellyang.com/2021/10/21/creating-reusable-kuma-installation-yaml/</link>
      <pubDate>Thu, 21 Oct 2021 09:15:00 -0600</pubDate>
      
      <guid>https://www.howellyang.com/2021/10/21/creating-reusable-kuma-installation-yaml/</guid>
      <description>&lt;p&gt;Using CLI tools&amp;mdash;instead of a &amp;ldquo;wall of YAML&amp;rdquo;&amp;mdash;to install things onto &lt;a href=&#34;https://kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; is a growing trend, it seems. &lt;a href=&#34;https://istio.io&#34;&gt;Istio&lt;/a&gt; and &lt;a href=&#34;https://cilium.io&#34;&gt;Cilium&lt;/a&gt;, for example, each have a CLI tool for installing their respective project. I get the reasons why; you can build logic into a CLI tool that you can&amp;rsquo;t build into a YAML file. &lt;a href=&#34;https://kuma.io&#34;&gt;Kuma&lt;/a&gt;, the open source service mesh maintained largely by Kong and a CNCF Sandbox project, takes a similar approach with its &lt;code&gt;kumactl&lt;/code&gt; tool. In this post, however, I&amp;rsquo;d like to take a look at creating reusable YAML to install Kuma, instead of using the CLI tool every time you install.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kustomize Transformer Configurations for Cluster API v1beta1</title>
      <link>https://www.howellyang.com/2021/10/11/kustomize-transformer-configurations-for-cluster-api-v1beta1/</link>
      <pubDate>Mon, 11 Oct 2021 16:00:00 -0600</pubDate>
      
      <guid>https://www.howellyang.com/2021/10/11/kustomize-transformer-configurations-for-cluster-api-v1beta1/</guid>
      <description>&lt;p&gt;The topic of combining &lt;a href=&#34;https://kustomize.io/&#34;&gt;&lt;code&gt;kustomize&lt;/code&gt;&lt;/a&gt; with &lt;a href=&#34;https://cluster-api.sigs.k8s.io/&#34;&gt;Cluster API&lt;/a&gt; (CAPI) is a topic I&amp;rsquo;ve touched on several times over the last 18-24 months. I first touched on this topic in November 2019 with a post on &lt;a href=&#34;https://www.howellyang.com/2019/11/12/using-kustomize-with-cluster-api-manifests/&#34;&gt;using &lt;code&gt;kustomize&lt;/code&gt; with CAPI manifests&lt;/a&gt;. A short while later, I discovered a way to change the configurations for the &lt;code&gt;kustomize&lt;/code&gt; transformers to make it easier to use it with CAPI. That resulted in two posts on changing the &lt;code&gt;kustomize&lt;/code&gt; transformers: &lt;a href=&#34;https://www.howellyang.com/2020/03/13/configuring-kustomize-transformers-for-cluster-api/&#34;&gt;one for v1alpha2&lt;/a&gt; and &lt;a href=&#34;https://www.howellyang.com/2020/03/17/kustomize-transformer-configuration-cluster-api-v1alpha3/&#34;&gt;one for v1alpha3&lt;/a&gt; (since there were changes to the API between versions). In this post, I&amp;rsquo;ll revisit &lt;code&gt;kustomize&lt;/code&gt; transformer configurations again, this time for CAPI v1beta1 (the API version corresponding to the CAPI 1.0 release).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kustomize Transformer Configurations for Cluster API v1alpha3</title>
      <link>https://www.howellyang.com/2020/03/17/kustomize-transformer-configuration-cluster-api-v1alpha3/</link>
      <pubDate>Tue, 17 Mar 2020 15:42:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2020/03/17/kustomize-transformer-configuration-cluster-api-v1alpha3/</guid>
      <description>&lt;p&gt;A few days ago I wrote an article on &lt;a href=&#34;https://www.howellyang.com/2020/03/13/configuring-kustomize-transformers-for-cluster-api/&#34;&gt;configuring &lt;code&gt;kustomize&lt;/code&gt; transformers&lt;/a&gt; for use with &lt;a href=&#34;https://cluster-api.sigs.k8s.io/introduction.html&#34;&gt;Cluster API (CAPI)&lt;/a&gt;, in which I explored how users could configure the &lt;code&gt;kustomize&lt;/code&gt; transformers&amp;mdash;the parts of &lt;code&gt;kustomize&lt;/code&gt; that actually modify objects&amp;mdash;to be a bit more CAPI-aware. By doing so, using &lt;code&gt;kustomize&lt;/code&gt; with CAPI manifests becomes much easier. Since that post, the CAPI team released v1alpha3. In working with v1alpha3, I realized my &lt;code&gt;kustomize&lt;/code&gt; transformer configurations were incorrect. In this post, I will share CAPI v1alpha3 configurations for &lt;code&gt;kustomize&lt;/code&gt; transformers.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Configuring Kustomize Transformers for Cluster API</title>
      <link>https://www.howellyang.com/2020/03/13/configuring-kustomize-transformers-for-cluster-api/</link>
      <pubDate>Fri, 13 Mar 2020 09:55:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2020/03/13/configuring-kustomize-transformers-for-cluster-api/</guid>
      <description>&lt;p&gt;In November 2019 I wrote an article on &lt;a href=&#34;https://www.howellyang.com/2019/11/12/using-kustomize-with-cluster-api-manifests/&#34;&gt;using &lt;code&gt;kustomize&lt;/code&gt; with Cluster API (CAPI) manifests&lt;/a&gt;. The idea was to use &lt;code&gt;kustomize&lt;/code&gt; to simplify the management of CAPI manifests for clusters that are generally similar but have minor differences (like the AWS region in which they are running, or the number of Machines in a MachineDeployment). In this post, I&amp;rsquo;d like to show a slightly different way of using &lt;code&gt;kustomize&lt;/code&gt; with Cluster API that involves configuring the &lt;code&gt;kustomize&lt;/code&gt; transformers.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Updating Visual Studio Code&#39;s Kubernetes API Awareness</title>
      <link>https://www.howellyang.com/2020/03/12/updating-vscode-kubernetes-api-awareness/</link>
      <pubDate>Thu, 12 Mar 2020 12:20:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2020/03/12/updating-vscode-kubernetes-api-awareness/</guid>
      <description>&lt;p&gt;After attempting (and failing) to get &lt;a href=&#34;https://www.sublimetext.com/&#34;&gt;Sublime Text&lt;/a&gt; to have some of the same &amp;ldquo;intelligence&amp;rdquo; that &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt; has with certain languages, I finally stopped trying to make Sublime Text work for me and just went back to using Code full-time. As I mentioned in &lt;a href=&#34;https://www.howellyang.com/2020/03/08/modifying-visual-studio-code-bracketing-behavior/&#34;&gt;this earlier post&lt;/a&gt;, now that I&amp;rsquo;ve finally solved how Code handles wrapping text in brackets and braces and the like I&amp;rsquo;m much happier. (It&amp;rsquo;s the small things in life.) Now I&amp;rsquo;ve moved on to tackling how to update Code&amp;rsquo;s Kubernetes API awareness.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using Kustomize with Cluster API Manifests</title>
      <link>https://www.howellyang.com/2019/11/12/using-kustomize-with-cluster-api-manifests/</link>
      <pubDate>Tue, 12 Nov 2019 19:57:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2019/11/12/using-kustomize-with-cluster-api-manifests/</guid>
      <description>&lt;p&gt;A topic that&amp;rsquo;s been in the back of my mind since writing &lt;a href=&#34;https://www.howellyang.com/2019/08/26/an-introduction-to-kubernetes-cluster-api/&#34;&gt;the Cluster API introduction post&lt;/a&gt; is how someone could use &lt;a href=&#34;https://kustomize.io/&#34;&gt;&lt;code&gt;kustomize&lt;/code&gt;&lt;/a&gt; to modify the &lt;a href=&#34;https://github.com/kubernetes-sigs/cluster-api&#34;&gt;Cluster API&lt;/a&gt; manifests. Fortunately, this is reasonably straightforward. It doesn&amp;rsquo;t require any &amp;ldquo;hacks&amp;rdquo; like those needed to &lt;a href=&#34;https://www.howellyang.com/2019/10/16/using-kustomize-with-kubeadm-configuration-files/&#34;&gt;use &lt;code&gt;kustomize&lt;/code&gt; with &lt;code&gt;kubeadm&lt;/code&gt; configuration files&lt;/a&gt;, but similar to modifying &lt;code&gt;kubeadm&lt;/code&gt; configuration files you&amp;rsquo;ll generally need to use the patching functionality of &lt;code&gt;kustomize&lt;/code&gt; when working with Cluster API manifests. In this post, I&amp;rsquo;d like to take a fairly detailed look at how someone might go about using &lt;code&gt;kustomize&lt;/code&gt; with Cluster API.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Programmatically Creating Kubernetes Manifests</title>
      <link>https://www.howellyang.com/2019/10/29/programmatically-creating-kubernetes-manifests/</link>
      <pubDate>Tue, 29 Oct 2019 07:30:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2019/10/29/programmatically-creating-kubernetes-manifests/</guid>
      <description>&lt;p&gt;A while ago I came across &lt;a href=&#34;https://jkcfg.github.io/#/&#34;&gt;a utility named &lt;code&gt;jk&lt;/code&gt;&lt;/a&gt;, which purported to be able to create structured text files&amp;mdash;in JSON, YAML, or HCL&amp;mdash;using JavaScript (or TypeScript that has been transpiled into JavaScript). One of the use cases was creating &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; manifests. The &lt;a href=&#34;https://github.com/jkcfg/jk&#34;&gt;GitHub repository for &lt;code&gt;jk&lt;/code&gt;&lt;/a&gt; describes it as &amp;ldquo;a data templating tool&amp;rdquo;, and that&amp;rsquo;s accurate for simple use cases. In more complex use cases, the use of a general-purpose programming language like JavaScript in &lt;code&gt;jk&lt;/code&gt; reveals that the tool has the potential to be much more than just a data templating tool&amp;mdash;if you have the JavaScript expertise to unlock that potential.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using Kustomize with Kubeadm Configuration Files</title>
      <link>https://www.howellyang.com/2019/10/16/using-kustomize-with-kubeadm-configuration-files/</link>
      <pubDate>Wed, 16 Oct 2019 10:00:00 -0700</pubDate>
      
      <guid>https://www.howellyang.com/2019/10/16/using-kustomize-with-kubeadm-configuration-files/</guid>
      <description>&lt;p&gt;Last week I had a crazy idea: if &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/&#34;&gt;&lt;code&gt;kustomize&lt;/code&gt;&lt;/a&gt; can be used to modify YAML files like &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; manifests, then could one use &lt;code&gt;kustomize&lt;/code&gt; to modify a &lt;code&gt;kubeadm&lt;/code&gt; configuration file, which is also a YAML manifest? So I asked about it in one of the Kubernetes-related channels in Slack at work, and as it turns out it&amp;rsquo;s not such a crazy idea after all! So, in this post, I&amp;rsquo;ll show you how to use &lt;code&gt;kustomize&lt;/code&gt; to modify &lt;code&gt;kubeadm&lt;/code&gt; configuration files.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploring Cluster API v1alpha2 Manifests</title>
      <link>https://www.howellyang.com/2019/09/26/exploring-cluster-api-v1alpha2-manifests/</link>
      <pubDate>Thu, 26 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2019/09/26/exploring-cluster-api-v1alpha2-manifests/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; community recently released v1alpha2 of Cluster API (a monumental effort, congrats to everyone involved!), and with it comes a number of fairly significant changes. Aside from &lt;a href=&#34;https://cluster-api.sigs.k8s.io/user/quick-start.html&#34;&gt;the new Quick Start&lt;/a&gt;, there isn&amp;rsquo;t (yet) a great deal of documentation on Cluster API (hereafter just called CAPI) v1alpha2, so in this post I&amp;rsquo;d like to explore the structure of the CAPI v1alpha2 YAML manifests, along with links back to the files that define the fields for the manifests. I&amp;rsquo;ll focus on the CAPI provider for AWS (affectionately known as CAPA).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>An Introduction to Kustomize</title>
      <link>https://www.howellyang.com/2019/09/13/an-introduction-to-kustomize/</link>
      <pubDate>Fri, 13 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2019/09/13/an-introduction-to-kustomize/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://kustomize.io&#34;&gt;&lt;code&gt;kustomize&lt;/code&gt;&lt;/a&gt; is a tool designed to let users &amp;ldquo;customize raw, template-free YAML files for multiple purposes, leaving the original YAML untouched and usable as is&amp;rdquo; (wording taken directly from &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize&#34;&gt;the &lt;code&gt;kustomize&lt;/code&gt; GitHub repository&lt;/a&gt;). Users can run &lt;code&gt;kustomize&lt;/code&gt; directly, or&amp;mdash;starting with &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; 1.14&amp;mdash;use &lt;code&gt;kubectl -k&lt;/code&gt; to access the functionality (although the standalone binary is newer than the functionality built into &lt;code&gt;kubectl&lt;/code&gt; as of the Kubernetes 1.15 release). In this post, I&amp;rsquo;d like to provide an introduction to &lt;code&gt;kustomize&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Technology Short Take 117</title>
      <link>https://www.howellyang.com/2019/08/02/technology-short-take-117/</link>
      <pubDate>Fri, 02 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2019/08/02/technology-short-take-117/</guid>
      <description>&lt;p&gt;Welcome to Technology Short Take #117! Here&amp;rsquo;s my latest gathering of links and articles from the around the World Wide Web (an &amp;ldquo;old school&amp;rdquo; reference for you right there). I&amp;rsquo;ve got a little bit of something for most everyone, except for the storage nerds (I&amp;rsquo;m leaving that to my friend J Metz this time around). Here&amp;rsquo;s hoping you find something useful!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>An Improved Way to use YAML with Vagrant</title>
      <link>https://www.howellyang.com/2016/01/14/improved-way-yaml-vagrant/</link>
      <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2016/01/14/improved-way-yaml-vagrant/</guid>
      <description>In this post, I&amp;rsquo;d like to share with you an improved way to use YAML with Vagrant. I first discussed the use of YAML with Vagrant in a post on simplifying multi-machine Vagrant environments, where I simply factored out variable data into an external YAML file. The original approach I described had (at least) one significant drawback, though, which this new approach adddresses.
(By the way, this &amp;ldquo;improved&amp;rdquo; way is probably just a matter of better coding.</description>
    </item>
    
    <item>
      <title>Multi-Container Docker with YAML and Vagrant</title>
      <link>https://www.howellyang.com/2015/02/11/multi-container-docker-yaml-vagrant/</link>
      <pubDate>Wed, 11 Feb 2015 10:50:00 +0000</pubDate>
      
      <guid>https://www.howellyang.com/2015/02/11/multi-container-docker-yaml-vagrant/</guid>
      <description>In this post, I&amp;rsquo;ll provide an example of using YAML to create a multi-container Docker environment in Vagrant. I made a brief mention of this technique in my earlier post talking about how to use Docker with Vagrant, but wanted to provide an example. For me, I know that examples are often quite helpful when I&amp;rsquo;m learning something new. Since one of my primary goals here is to help enable others to learn these technologies, I figured an example would be helpful.</description>
    </item>
    
  </channel>
</rss>
