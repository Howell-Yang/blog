<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Introduction to Networking: Part 2, A Few More Basics - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</title>

  
  <meta name="author" content="Howell Yang">
  <meta property="og:site_name" content="Scott&#39;s Weblog">
  
  <meta property="og:description" content="Introduction to Networking: Part 2, A Few More Basics - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  <meta property="og:title" content="Introduction to Networking: Part 2, A Few More Basics - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  
  <meta property="og:type" content="article">
  <meta name="keywords" content="Cloud, Containers, Kubernetes, K8s, Docker, CNI, CRI-O, OCI, Linux, CLI, Networking, AWS, Security, DevOps">

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/public/font-awesome/css/font-awesome.min.css">

  
  <link rel="canonical" href="https://www.howellyang.com/2013/10/07/introduction-to-networking-part-2-a-few-more-basics/">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">

  
  </head>
<body class="theme-base-0d">
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><img src="/public/img/orbits-thumb.gif" alt="Orbits" width="128" height="128" /></p>
    <p>Original, technical content centered around cloud computing, Kubernetes, Linux, and networking</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="/">Home</a>
    <a class="sidebar-nav-item" href="/about/">About</a>
    <a class="sidebar-nav-item" href="/archives/">Site Archives</a>
    <a class="sidebar-nav-item" href="/categories/">Post Categories</a>
    <a class="sidebar-nav-item" href="/tags/">Content Tags</a>
  </nav>

  <div class="sidebar-item">
    <p>
      <a href="https://github.com/howellyang"><i class="fa fa-github fa-3x"></i></a>
      <a href="https://twitter.com/None"><i class="fa fa-twitter fa-3x"></i></a>
      <a href="https://www.linkedin.com/in/None"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="http://feeds.scottlowe.org/slowe/content/feed/"><i class="fa fa-rss fa-3x"></i></a>
    </p>
  </div>

  <div class="sidebar-item">
    <p>&copy; 2005-2022. All rights reserved.</p>
  </div>
</div>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Howell Yang&#39;s Weblog</a>
            <small>我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</small>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="post">
  <h1 class="post-title">Introduction to Networking: Part 2, A Few More Basics</h1>
  <span class="post-date"><i class="fa fa-calendar" aria-hidden="true"></i>&#160;Published on 79 May 7077 &middot;
    <i class="fa fa-folder-open-o" aria-hidden="true"></i>&#160;Filed in <a href="/categories/education">Education</a> &middot;
    <i class="fa fa-pencil" aria-hidden="true"></i>&#160;1669 words (estimated 8 minutes to read)</span>
  <p>In <a href="/2013/08/12/introduction-to-networking-part-1-the-basics/">part 1</a> of this series, I covered some networking basics (OSI and DoD models; layer 2 vs. layer 3; bridging, switching, and routing; Spanning Tree Protocol; and ARP and flooding). In this part, I&rsquo;m going to build on those basic concepts to introduce a few more fundamental building blocks. As the series progresses, I&rsquo;ll continue to build on concepts and technologies introduced in earlier sections.</p>
<p>In this part, we&rsquo;ll discuss:</p>
<ul>
<li>
<p>VLANs</p>
</li>
<li>
<p>VLAN Trunks</p>
</li>
<li>
<p>Link Aggregation</p>
</li>
</ul>
<p>I&rsquo;ll start with VLANs.</p>
<h2 id="vlans">VLANs</h2>
<p>Recall that in <a href="/2013/08/12/introduction-to-networking-part-1-the-basics/">part 1</a> I defined a <em>broadcast domain</em> as all the devices and hosts that are connected by bridges or switches (which operate at layer 2, the Data Link layer, of the OSI model). This means that, by default, every host plugged into a switch will automatically be part of the same broadcast domain. But what if you wanted to have multiple broadcast domains on the same switch? A <em>virtual LAN</em>, aka a <em>VLAN</em>, allows you to have this ability. Defined in its simplest terms, a VLAN is a layer 2 broadcast domain. A switch that supports VLANs supports the ability to be &ldquo;subdivided&rdquo; into multiple broadcast domains. In order for traffic to pass from one VLAN to another VLAN (i.e., from one broadcast domain into another broadcast domain), a layer 3 router is needed.</p>
<p>VLANs work by leveraging a 12-bit identifier in the Ethernet frame format (see <a href="https://en.wikipedia.org/wiki/IEEE_802.1Q">here</a> for more details). This 12-bit identifier, often referred to as the VLAN tag, allows for up to 4,094 VLANs (212 = 4,096, with all zeroes [0x000 hexadecimal] and all ones [0xFFF hexadecimal] reserved). Not all switches from all vendors support using all 4,094 VLANs; some switches might support fewer than that.</p>
<p>&lt;aside&gt;As a side note, you might note that 802.1Q doesn&rsquo;t actually <em>encapsulate</em> the original Ethernet frame. In other words, it doesn&rsquo;t wrap its own headers before and after the original Ethernet frame; rather, it injects the 12-bit VLAN tag into the frame just after the source MAC header.&lt;/aside&gt;</p>
<p>Although adding support for VLANs to a switch allows that switch to support multiple broadcast domains, it doesn&rsquo;t change certain layer 2 switching behaviors. In particular, the switch may still need to use flooding (described in part 1) to learn which MAC addresses are associated with which switch ports. The key difference is that flooding will only occur <em>within</em> a VLAN, since flooding is limited to a broadcast domain.</p>
<p>Finally, it&rsquo;s important to note that VLANs themselves are strictly layer 2 constructs, but because a layer 3 router is needed to pass traffic between them, VLANs are often associated with IP subnets&mdash;meaning that each VLAN is considered a unique IP network. It&rsquo;s probably for this reason that some people use the terms &ldquo;IP subnet&rdquo; and &ldquo;VLAN&rdquo; interchangeably when, as you can see, they aren&rsquo;t necessarily the same thing. (You could, for example, have two different IP subnets running on the same broadcast domain.) Generally speaking, though, it&rsquo;s very common for each VLAN to represent a unique IP subnet.</p>
<h2 id="vlan-trunks">VLAN Trunks</h2>
<p>OK, so a VLAN allows me to subdivide a switch into multiple broadcast domains. What if I have multiple switches? The IEEE 802.1Q standard that defines VLANs also defines a way for two switches to multiplex VLANs over a single link. (Without this functionality, the only way to connect multiple switches together while still preserving VLANs would be to have separate physical connections for each VLAN&mdash;clearly not very efficient.) A connection that carries multiple VLANs is often referred to as a <em>VLAN trunk</em> (although some might say that this is a very Cisco-centric term). Note that VLAN trunks don&rsquo;t handle switch configuration; if you want two switches connected by a VLAN trunk to &ldquo;share&rdquo; the same VLANs, you&rsquo;ll still need to configure the VLANs on each switch.</p>
<p>Allow me to use a practical example to help illustrate this point. Assume you have SwitchA that has two VLANs defined (VLAN 100 and VLAN 200). Further assume that you have SwitchB with two VLANs, VLAN 200 and VLAN 300, defined. No layer 3 router is present. A VLAN trunk connects SwitchA and SwitchB. Here&rsquo;s the resulting connectivity matrix:</p>
<ol>
<li>
<p>HostA in VLAN 100 attached to SwitchA won&rsquo;t be able to communicate with any hosts attached to SwitchB (there is a VLAN trunk between the switches, but SwitchB doesn&rsquo;t have VLAN 100 defined and VLAN 200 is a separate broadcast domain).</p>
</li>
<li>
<p>HostA in VLAN 200 attached to SwitchA will be able to communicate with hosts in VLAN 200 attached to SwitchB (the VLAN is defined on both switches and there is a VLAN trunk between the switches).</p>
</li>
<li>
<p>HostB in VLAN 200 attached to SwitchB will be able to communicate with hosts in VLAN 200 attached to SwitchA (the VLAN is defined on both switches and there is a VLAN trunk between the switches).</p>
</li>
<li>
<p>HostC in VLAN 300 attached to SwitchB will not be able to communicate with any hosts attached to SwitchA (there is a VLAN trunk between the switches, but SwitchA doesn&rsquo;t have VLAN 300 defined, and the VLANs that <em>are</em> defined are separate broadcast domains).</p>
</li>
</ol>
<p>(There are a few &ldquo;gotchas&rdquo; to this relatively simple example, like native/untagged VLANs and VLAN pruning across the trunk, but this discussion should suffice for now.)</p>
<p>The key takeaway is that in order for VLANs to span multiple physical switches, you need a) matching VLAN configurations across the physical switches, and b) a VLAN trunk connecting the physical switches. Without both of these, connectivity generally won&rsquo;t work. When both of these conditions are present, the VLAN (and therefore the broadcast domain) is extended across both switches. It should be fairly obvious at this point that by extending the VLAN across both switches, you&rsquo;ve subjected ports in that VLAN on both switches to broadcasts and flooding (because they are in the same broadcast domain).</p>
<p>(Side note: STP also had to be modified to account for VLANs and VLAN trunks to ensure that bridging loops were not created within each VLAN. This gave rise to a group of STP versions, such as PVST and the like.)</p>
<h2 id="link-aggregation">Link Aggregation</h2>
<p>In <a href="/2013/08/12/introduction-to-networking-part-1-the-basics/">part 1</a> I introduced Spanning Tree Protocol (STP) (more information <a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">here</a>), which the networking experts created to eliminate switching loops (which were a Bad Thing because there is no TTL-like mechanism at layer 2 to remove &ldquo;old&rdquo; or &ldquo;stale&rdquo; traffic from the network). While preventing switching loops is a Good Thing, one by-product of STP is that it blocks redundant switch-to-switch connections in the same broadcast domain. So what could you do if you needed more bandwidth between switches than a single link could offer?</p>
<p>This is where <em>link aggregation</em> comes into play. Link aggregation allows switches to combine multiple physical links into one logical link, allowing for a greater amount of aggregate bandwidth between the switches. For example, I might configure 4 individual 1 Gbps physical links into a single logical link, giving me a total of 4 Gbps aggregate throughput between the two switches. The key phrase here is <em>aggregate throughput</em>; it&rsquo;s really important to understand that any single traffic flow will only be able to use a single physical link.</p>
<p>Let me explain why. Let&rsquo;s suppose that you have 4 links combined into a single logical link between two switches (I&rsquo;ll be creative and call them SwitchA and SwitchB). When traffic enters SwitchA bound for SwitchB, SwitchA needs to decide how to place the traffic on the individual members of the logical link. Switches generally support a variety of load balancing mechanisms, including source-destination MAC addresses, source-destination IP addresses, and sometimes even layer 4 (TCP/UDP) source-destination ports. For the purposes of this discussion, I&rsquo;ll assume that the load balancing is being done based on source and destination IP address. The traffic enters SwitchA, originating from HostA and bound for HostB attached to SwitchB. There is a link aggregate configured between SwitchA and SwitchB, so SwitchA performs a hash of the source and destination IP addresses. The result of that hash&mdash;which would be a number ranging from 0 to 3, since there are 4 links in the link aggregate&mdash;tells SwitchA which physical link to use in the logical link. SwitchA places the traffic on the physical link and off it goes. When HostB replies, SwitchB has to go through the same process, so it calculates a hash based on the source and destination IP addresses, determines which link in the aggregate to use, and off it goes.</p>
<p>There are a couple of key takeaways from this:</p>
<ol>
<li>
<p>Both switches need to be configured to use link aggregation, and the configuration has to match on each end. If SwitchA was configured to use 2 links but SwitchB was configured to use 4 links, we&rsquo;d very likely run into issues.</p>
</li>
<li>
<p>Any given traffic flow between two endpoints will <em>always</em> be limited to the bandwidth of a single link within the aggregate. Why? Look back to the explanation above: the switches will create a hash based on some variables (MAC addresses, IP addresses, source and destination TCP/UDP ports) to determine which link to use. As long as all the variables are the same&mdash;which they would be for a single traffic flow&mdash;the hash is deterministic and always returns the same result. Therefore, the same link is always used for that particular traffic flow.</p>
</li>
</ol>
<p>Takeaway #2 has significant implications, which I&rsquo;ll explore in more detail in future posts. (Here&rsquo;s <a href="/2012/07/03/vsphere-on-nfs-design-considerations-presentation/">an example</a>; see slides 5 through 7 in particular.)</p>
<p>There are a number of protocols involved in link aggregation; the most common protocol is Link Aggregation Control Protocol (LACP), which is designed to enable switches to negotiate the use of link aggregation between them (when used properly, this helps address takeaway #1). You may also see references to &ldquo;EtherChannel&rdquo;; this is a Cisco-specific term that is also used to describe the use of link aggregation.</p>
<p>That&rsquo;s probably enough information for now. If you have any questions about any of the information I&rsquo;ve presented here, please feel free to speak up in the comments. I welcome all courteous comments, so join in the discussion!</p>


  <h3>Metadata and Navigation</h3>
  <span class="post-meta">
  <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/networking">Networking</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/vlan">VLAN</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/lacp">LACP</a> 

  <br />
  <i class="fa fa-arrow-circle-left" aria-hidden="true"></i> Previous Post: <a href="https://www.howellyang.com/2013/10/04/using-puppet-for-ubuntu-cloud-archive-support/">Using Puppet for Ubuntu Cloud Archive Support</a>
  
  <br />
   <i class="fa fa-arrow-circle-right" aria-hidden="true"></i> Next Post: <a href="https://www.howellyang.com/2013/10/10/using-puppet-to-configure-ubuntu-to-use-apt-cacher-ng/">Using Puppet to Configure Ubuntu to use Apt-Cacher-NG</a>
  </span>

  <span class="post-sharing">
  <p>Be social and share this post!<br />

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.howellyang.com%2f2013%2f10%2f07%2fintroduction-to-networking-part-2-a-few-more-basics%2f" title="Share on Facebook"><i class="fa fa-facebook-square fa-2x"></i></a>
  <a href="https://twitter.com/intent/tweet?url=https%3a%2f%2fwww.howellyang.com%2f2013%2f10%2f07%2fintroduction-to-networking-part-2-a-few-more-basics%2f&text=Introduction%20to%20Networking%3a%20Part%202%2c%20A%20Few%20More%20Basics" title="Share on Twitter"><i class="fa fa-twitter-square fa-2x"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2fwww.howellyang.com%2f2013%2f10%2f07%2fintroduction-to-networking-part-2-a-few-more-basics%2f" title="Share on Google Plus"><i class="fa fa-google-plus-square fa-2x"></i></a></p>
  </span>
</div>

<div class="related">
  <h3>Related Posts</h3>
  <ul class="related-posts">
  <li><a href="/2013/06/20/thinking-out-loud-the-future-of-vlans/">Thinking Out Loud: The Future of VLANs</a> <span class="post-date-list">209 May 202020</span></li><li><a href="/2013/05/28/vlan-trunking-to-guest-domains-with-open-vswitch/">VLAN Trunking to Guest Domains with Open vSwitch</a> <span class="post-date-list">289 May 282828</span></li><li><a href="/2012/11/07/using-vlans-with-ovs-and-libvirt/">Using VLANs with OVS and libvirt</a> <span class="post-date-list">79 May 7077</span></li>
  </ul>
</div>      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>
