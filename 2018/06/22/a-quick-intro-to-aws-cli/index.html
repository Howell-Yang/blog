<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>A Quick Intro to the AWS CLI - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</title>

  
  <meta name="author" content="Howell Yang">
  <meta property="og:site_name" content="Scott&#39;s Weblog">
  
  <meta property="og:description" content="A Quick Intro to the AWS CLI - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  <meta property="og:title" content="A Quick Intro to the AWS CLI - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  
  <meta property="og:type" content="article">
  <meta name="keywords" content="Cloud, Containers, Kubernetes, K8s, Docker, CNI, CRI-O, OCI, Linux, CLI, Networking, AWS, Security, DevOps">

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/public/font-awesome/css/font-awesome.min.css">

  
  <link rel="canonical" href="https://www.howellyang.com/2018/06/22/a-quick-intro-to-aws-cli/">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">

  
  </head>
<body class="theme-base-0d">
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><img src="/public/img/orbits-thumb.gif" alt="Orbits" width="128" height="128" /></p>
    <p>Original, technical content centered around cloud computing, Kubernetes, Linux, and networking</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="/">Home</a>
    <a class="sidebar-nav-item" href="/about/">About</a>
    <a class="sidebar-nav-item" href="/archives/">Site Archives</a>
    <a class="sidebar-nav-item" href="/categories/">Post Categories</a>
    <a class="sidebar-nav-item" href="/tags/">Content Tags</a>
  </nav>

  <div class="sidebar-item">
    <p>
      <a href="https://github.com/howellyang"><i class="fa fa-github fa-3x"></i></a>
      <a href="https://twitter.com/None"><i class="fa fa-twitter fa-3x"></i></a>
      <a href="https://www.linkedin.com/in/None"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="http://feeds.scottlowe.org/slowe/content/feed/"><i class="fa fa-rss fa-3x"></i></a>
    </p>
  </div>

  <div class="sidebar-item">
    <p>&copy; 2005-2022. All rights reserved.</p>
  </div>
</div>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Howell Yang&#39;s Weblog</a>
            <small>我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</small>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="post">
  <h1 class="post-title">A Quick Intro to the AWS CLI</h1>
  <span class="post-date"><i class="fa fa-calendar" aria-hidden="true"></i>&#160;Published on 229 May 222222 &middot;
    <i class="fa fa-folder-open-o" aria-hidden="true"></i>&#160;Filed in <a href="/categories/education">Education</a> &middot;
    <i class="fa fa-pencil" aria-hidden="true"></i>&#160;1670 words (estimated 8 minutes to read)</span>
  <p>This post provides a (very) basic introduction to the <a href="https://aws.amazon.com/cli/">AWS CLI (command-line interface)</a> tool. It&rsquo;s not intended to be a deep dive, nor is it intended to serve as a comprehensive reference guide (the <a href="http://docs.aws.amazon.com/cli/latest/reference/">AWS CLI docs</a> nicely fill that need). I also assume that you already have a basic understanding of the key AWS concepts and terminology, so I won&rsquo;t bore you with defining an instance, VPC, subnet, or security group.</p>
<p>For the purposes of this introduction, I&rsquo;ll structure it around launching an EC2 instance. As it turns out, there&rsquo;s a fair amount of information you need before you can launch an AWS instance using the AWS CLI. So, let&rsquo;s look at how you would use the AWS CLI to help get the information you need in order to launch an instance using the AWS CLI. (Tool inception!)</p>
<p>To launch an instance, you need five pieces of information:</p>
<ol>
<li>The ID of an Amazon Machine Image (AMI)</li>
<li>The type of instance you&rsquo;re going to launch</li>
<li>The name of the SSH keypair you&rsquo;d like to inject into the instance</li>
<li>The ID of the security group to which this instance should be added</li>
<li>The ID of the subnet on which this instance should be placed</li>
</ol>
<p>Some (most?) of this information is easily located via the AWS console, but I&rsquo;ll use the CLI nevertheless.</p>
<p>Let&rsquo;s start by determining the name of the SSH keypair you&rsquo;d like to inject into the instance (this is assuming you&rsquo;re launching a Linux-based instance). The basic format for AWS CLI commands looks something like <code>aws &lt;service&gt; &lt;command&gt;</code>. In this case, we&rsquo;re dealing with the EC2 service, and we want to get a list of&mdash;or <em>describe</em>&mdash;the SSH keypairs. So the command looks like this:</p>
<pre><code>aws ec2 describe-key-pairs
</code></pre>
<p>What you&rsquo;ll get back is JSON (see <a href="/2013/11/08/a-non-programmers-introduction-to-json/">this article</a> if you need a quick introduction to JSON) that looks something like this (some of the data has been randomized to protect the innocent):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;KeyPairs&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;KeyName&#34;</span>: <span style="color:#e6db74">&#34;key_pair_name&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;KeyFingerprint&#34;</span>: <span style="color:#e6db74">&#34;57:ca:27:99:fe:2a:24:60:8e:7f:b4:de:ad:be:ef:f1&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because it&rsquo;s JSON, you can use handy tools like <code>jq</code> to manipulate and format this data. (If you aren&rsquo;t familiar with <code>jq</code>, see <a href="/2015/11/11/handy-cli-tool-json/">this article</a>.) So, let&rsquo;s say you wanted to extract the keypair name into a variable so you can re-use it later. That command looks something like this:</p>
<pre><code>KEYPAIR=$(aws ec2 describe-key-pairs | jq -r '.KeyPairs[0].KeyName')
</code></pre>
<p>Subsequently running <code>echo $KEYPAIR</code> would produce the output <code>key_pair_name</code>, showing you that you&rsquo;ve successfully extracted the name of the keypair into the variable named KEYPAIR. This trick&mdash;assigning the output of a command to a variable&mdash;is a trick of the Bash shell called <em>command substitution</em>, and I&rsquo;ll use it extensively in this article to store pieces of information we&rsquo;ll need later.</p>
<p>Next, you&rsquo;ll need to know what type of instance you want to launch. Rodney &ldquo;Rodos&rdquo; Haywood has a great article on <a href="http://rodos.haywood.org/2016/03/which-instances-are-available-in-my.html">determining which instances are available in your region</a>. For now, we&rsquo;ll just assume you want to create a &ldquo;t2.micro&rdquo; instance.</p>
<p>Next, let&rsquo;s track down security group and subnet information. To retrieve security group details, you&rsquo;d use this command:</p>
<pre><code>aws ec2 describe-security-groups
</code></pre>
<p>This will return a list of security groups and the rules in the security groups, so the output will be lengthy and/or complex. Once again we&rsquo;ll turn to <code>jq</code> to help parse the information down to show us only the group ID of the default security group:</p>
<pre><code>aws ec2 describe-security-groups | jq '.SecurityGroups[] | select (.GroupName == &quot;default&quot;) | .GroupId'
</code></pre>
<p>This finds the group whose <code>GroupName</code> key has the value &ldquo;default&rdquo; (i.e., the security group named &ldquo;default&rdquo;) and returns the group ID. You could modify the value for which you&rsquo;re searching as needed, of course.</p>
<p>You can use Bash command substitution to place the output of this command into a variable we&rsquo;ll use later:</p>
<pre><code>SG_ID=$(aws ec2 describe-security-groups | jq -r '.SecurityGroups[] | select (.GroupName == &quot;default&quot;) | .GroupId')
</code></pre>
<p>In reviewing the output of the <code>aws ec2 describe-security-groups</code> command, perhaps you notice the security group doesn&rsquo;t allow SSH access. That will be problematic, as SSH is the nearly-universal means by which you gain access to Linux- and UNIX-based instances. We can fix that pretty easily with the oh-so-intuitively-named <code>aws ec2 authorize-security-group-ingress</code> command:</p>
<pre><code>aws ec2 authorize-security-group-ingress --group-id &lt;value&gt; --protocol &lt;tcp|udp|icmp&gt; --port &lt;value&gt; --cidr &lt;value&gt;
</code></pre>
<p>To allow SSH access, then, we&rsquo;ll use the <code>$SG_ID</code> value we obtained earlier and plug in the correct values for SSH:</p>
<pre><code>aws ec2 authorize-security-group-ingress --group-id $SG_ID \
--protocol tcp --port 22 --cidr 0.0.0.0/0
</code></pre>
<p>And now our soon-to-be-launched instance will be available via SSH! (If you decide you don&rsquo;t want SSH access, just use the <code>aws ec2 revoke-security-group-ingress</code> command, which has the same syntax as the <code>aws ec2 authorize-security-group-ingress</code> command.)</p>
<p>So far, we&rsquo;ve gathered the SSH key pair, the instance type, and the security group ID. Determining the next piece of information we need&mdash;the subnet ID&mdash;is pretty straightforward as well. The basic command is <code>aws ec2 describe-subnets</code>; when it&rsquo;s combined with a <code>jq</code> filter we can get the subnet ID for the subnet in a particular availability zone. Let&rsquo;s say we want the subnet from the &ldquo;us-west-2b&rdquo; availability zone:</p>
<pre><code>aws ec2 describe-subnets | jq '.Subnets[] | select(.AvailabilityZone == &quot;us-west-2b&quot;) | .SubnetId'
</code></pre>
<p>This uses the same <code>jq</code> syntax we used with the security groups: finds the subnet object whose AvailabilityZone key is equal to &ldquo;us-west-2b&rdquo;, then returns the ID for that subnet.</p>
<p>Naturally, we&rsquo;ll store this value in a variable for use later (adding the <code>-r</code> flag to <code>jq</code> to return the value in plain text, not as JSON):</p>
<pre><code>SUBNET_ID=$(aws ec2 describe-subnets | jq -r '.Subnets[] | select(.AvailabilityZone == &quot;us-west-2b&quot;) | .SubnetId')
</code></pre>
<p>We&rsquo;re now left with only the AMI (Amazon Machine Image). I&rsquo;ve saved this for last as some might consider it the most complex of the tasks. As you&rsquo;ve likely guessed, the basic command is <code>aws ec2 describe-images</code>. However, you can&rsquo;t just run that command; it will return <em>way</em> too much information. (Go ahead and try it, I&rsquo;ll wait here.)</p>
<p>To limit the amount of information returned by the <code>aws ec2 describe-images</code> command, we need to use some server-side filtering/querying functionality. There&rsquo;s a few different tricks we can use here:</p>
<ul>
<li>
<p>First, we can add the <code>--owners</code> flag to limit the command to show AMIs belonging to a specific account. Let&rsquo;s suppose that we&rsquo;re looking for an Ubuntu AMI; in the case, we&rsquo;d use the owner ID of &ldquo;099720109477&rdquo;, so that the command would look like this:</p>
<pre><code>  aws ec2 describe-images --owners 099720109477
</code></pre>
</li>
<li>
<p>However, that&rsquo;s not enough, because we still get far too many values returned. To whittle down the list even further, the AWS CLI supports the  &ldquo;&ndash;filters&rdquo; parameter, which allows us to add more constraints to the list. The most useful filter, in my opinion, is filtering on the Name value. This allows you to do &ldquo;wildcard&rdquo; searches for AMIs whose name match a pattern. Here&rsquo;s an example:</p>
<pre><code>  aws ec2 describe-images --owners 099720109477 \
  --filters Name=name,Values='*ubuntu-xenial-16.04*'
</code></pre>
<p>This will still return too much information, but we can tack on additional filters as needed:</p>
<pre><code>  aws ec2 describe-images --owners 099720109477 \
  --filters Name=root-device-type,Values=ebs \
  Name=architecture, Values=x86_64 \
  Name=name,Values='*ubuntu-xenial-16.04*' \
  Name=virtualization-type,Values=hvm
</code></pre>
<p>Here you can see I&rsquo;ve added filters to show only AMIs that use EBS as the root volume type, are hardware-virtualized images, and are 64-bit images. The full list of available filters for the <code>describe-images</code> command is available <a href="https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-images.html">here</a>.</p>
</li>
<li>
<p>Our final trick is to add a server-side query to the command. This query uses JMESPath syntax (which I won&rsquo;t cover here because that&rsquo;s enough for a separate post on its own). Here&rsquo;s an example of using a server-side query to show only the most recent AMI that matches the rest of the criteria:</p>
<pre><code>  aws ec2 describe-images --owners 099720109477 --filters Name=root-device-type,Values=ebs Name=architecture,Values=x86_64 Name=name,Values='*ubuntu-xenial-16.04*' Name=virtualization-type,Values=hvm --query 'sort_by(Images, &amp;Name)[-1].ImageId'
</code></pre>
<p>The last and final step would be to store the value this command returns into a variable for use later:</p>
<pre><code>  IMAGE_ID=$(aws ec2 describe-images --owners 099720109477 --filters Name=root-device-type,Values=ebs Name=architecture,Values=x86_64 Name=name,Values='*ubuntu-xenial-16.04*' Name=virtualization-type,Values=hvm --query 'sort_by(Images, &amp;Name)[-1].ImageId')
</code></pre>
</li>
</ul>
<p>At this point, we&rsquo;ve gathered all the information we need to launch an AWS instance. The command to use is (drum roll, please) <code>aws ec2 run-instances</code>, and we&rsquo;ll plug in the variables we&rsquo;ve created along the way to supply all the necessary information. Here&rsquo;s what the final command would look like (I&rsquo;ve wrapped it with backslashes for improved readability):</p>
<pre><code>aws ec2 run-instances --image-id $IMAGE_ID \
--count 1 --instance-type t2.micro \
--key-name $KEYPAIR \
--security-group-ids $SG_ID \
--subnet-id $SUBNET_ID
</code></pre>
<p>This command will also return some JSON, which will include the instance IDs of the instances we just launched. We&rsquo;ll ignore that output for now for the sake of being able to show a few more ways to use the AWS CLI.</p>
<p>With an instance now running, let&rsquo;s retrieve the details of the instance with another AWS CLI command:</p>
<pre><code>aws ec2 describe-instances
</code></pre>
<p>This command also returns a pretty fair amount of information, and again we can use <code>jq</code> to filter down the information to show <em>only</em> the details you need. Suppose you need to see the private and public IP addresses assigned to the instance you just launched. With this set of <code>jq</code> filters, that&rsquo;s exactly what you&rsquo;ll see:</p>
<pre><code>aws ec2 describe-instances | jq '.Reservations[].Instances[] | { instance: .InstanceId, publicip: .PublicIpAddress, privateip: .PrivateIpAddress }'
</code></pre>
<p>Handy! I could run through a dozen more examples, but I think you get the point now.</p>
<p>Let&rsquo;s move on to terminating an instance. In order to terminate an instance&mdash;and you guessed it, the appropriate command is <code>aws ec2 terminate-instances</code> as expected&mdash;we&rsquo;ll need the instance IDs. Turning back to <code>jq</code> again:</p>
<pre><code>aws ec2 describe-instances | jq '.Reservations[].Instances[] | .InstanceId'
</code></pre>
<p>And once again using command substitution store that into a variable:</p>
<pre><code>INSTANCE_ID=$(aws ec2 describe-instances | jq -r '.Reservations[].Instances[] | .InstanceId')
</code></pre>
<p>Then we can plug that value into this command to terminate instances:</p>
<pre><code>aws ec2 terminate-instances --instance-ids $INSTANCE_ID
</code></pre>
<p>Hopefully this quick introduction to basic tasks you can perform with the AWS CLI has been useful. Feel free to <a href="https://twitter.com/scott_lowe">hit me on Twitter</a> if you have questions. If you have suggestions for improving this article, I invite you to open an issue or file a PR <a href="https://github.com/scottslowe/weblog">on the GitHub repository for this site</a>.</p>

  <h3>Metadata and Navigation</h3>
  <span class="post-meta">
  <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/aws">AWS</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/cli">CLI</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/json">JSON</a> 

  <br />
  <i class="fa fa-arrow-circle-left" aria-hidden="true"></i> Previous Post: <a href="https://www.howellyang.com/2018/06/12/examining-x509-certificates-embedded-in-kubeconfig-files/">Examining X.509 Certificates Embedded in Kubeconfig Files</a>
  
  <br />
   <i class="fa fa-arrow-circle-right" aria-hidden="true"></i> Next Post: <a href="https://www.howellyang.com/2018/06/28/more-handy-cli-tools-json/">More Handy CLI Tools for JSON</a>
  </span>

  <span class="post-sharing">
  <p>Be social and share this post!<br />

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.howellyang.com%2f2018%2f06%2f22%2fa-quick-intro-to-aws-cli%2f" title="Share on Facebook"><i class="fa fa-facebook-square fa-2x"></i></a>
  <a href="https://twitter.com/intent/tweet?url=https%3a%2f%2fwww.howellyang.com%2f2018%2f06%2f22%2fa-quick-intro-to-aws-cli%2f&text=A%20Quick%20Intro%20to%20the%20AWS%20CLI" title="Share on Twitter"><i class="fa fa-twitter-square fa-2x"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2fwww.howellyang.com%2f2018%2f06%2f22%2fa-quick-intro-to-aws-cli%2f" title="Share on Google Plus"><i class="fa fa-google-plus-square fa-2x"></i></a></p>
  </span>
</div>

<div class="related">
  <h3>Related Posts</h3>
  <ul class="related-posts">
  <li><a href="/2018/05/23/quick-post-parsing-aws-instance-data-with-jq/">Quick Post: Parsing AWS Instance Data with JQ</a> <span class="post-date-list">239 May 232323</span></li><li><a href="/2017/08/15/quick-reference-common-aws-cli-commands/">Quick Reference to Common AWS CLI Commands</a> <span class="post-date-list">159 May 151515</span></li><li><a href="/2018/06/08/quadruple-provider-vagrant-environment/">A Quadruple-Provider Vagrant Environment</a> <span class="post-date-list">89 May 8088</span></li>
  </ul>
</div>      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>
