<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Running a Small Docker Swarm Cluster - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</title>

  
  <meta name="author" content="Howell Yang">
  <meta property="og:site_name" content="Scott&#39;s Weblog">
  
  <meta property="og:description" content="Running a Small Docker Swarm Cluster - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  <meta property="og:title" content="Running a Small Docker Swarm Cluster - Howell Yang&#39;s Weblog - 我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。">
  
  <meta property="og:type" content="article">
  <meta name="keywords" content="Cloud, Containers, Kubernetes, K8s, Docker, CNI, CRI-O, OCI, Linux, CLI, Networking, AWS, Security, DevOps">

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/public/font-awesome/css/font-awesome.min.css">

  
  <link rel="canonical" href="https://www.howellyang.com/2015/03/06/running-own-docker-swarm-cluster/">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">

  
  </head>
<body class="theme-base-0d">
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><img src="/public/img/orbits-thumb.gif" alt="Orbits" width="128" height="128" /></p>
    <p>Original, technical content centered around cloud computing, Kubernetes, Linux, and networking</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="/">Home</a>
    <a class="sidebar-nav-item" href="/about/">About</a>
    <a class="sidebar-nav-item" href="/archives/">Site Archives</a>
    <a class="sidebar-nav-item" href="/categories/">Post Categories</a>
    <a class="sidebar-nav-item" href="/tags/">Content Tags</a>
  </nav>

  <div class="sidebar-item">
    <p>
      <a href="https://github.com/howellyang"><i class="fa fa-github fa-3x"></i></a>
      <a href="https://twitter.com/None"><i class="fa fa-twitter fa-3x"></i></a>
      <a href="https://www.linkedin.com/in/None"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="http://feeds.scottlowe.org/slowe/content/feed/"><i class="fa fa-rss fa-3x"></i></a>
    </p>
  </div>

  <div class="sidebar-item">
    <p>&copy; 2005-2022. All rights reserved.</p>
  </div>
</div>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Howell Yang&#39;s Weblog</a>
            <small>我是杨豪，专注于深度学习模型的训练、剪枝、量化、部署以及工程效率优化。欢迎来到我的博客。</small>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="post">
  <h1 class="post-title">Running a Small Docker Swarm Cluster</h1>
  <span class="post-date"><i class="fa fa-calendar" aria-hidden="true"></i>&#160;Published on 69 May 6066 &middot;
    <i class="fa fa-folder-open-o" aria-hidden="true"></i>&#160;Filed in <a href="/categories/tutorial">Tutorial</a> &middot;
    <i class="fa fa-pencil" aria-hidden="true"></i>&#160;2095 words (estimated 10 minutes to read)</span>
  <p>In this post, I&rsquo;m going to show you how to set up and run your own <a href="https://docs.docker.com/swarm/">Docker Swarm</a> cluster. Docker Swarm is a relatively new orchestration tool from <a href="https://www.docker.com">Docker</a> (the company) that allows you to create a cluster of hosts running Docker (the open source project) and schedule containers across the cluster. However, just scheduling and running containers across a cluster isn&rsquo;t enough, so I&rsquo;ll show you how to add service registration and service discovery to this environment using <a href="http://www.consul.io">Consul</a>.</p>
<p>In the event you&rsquo;re interested in following along, I&rsquo;ve created a set of files that will allow you to use <a href="http://www.vagrantup.com">Vagrant</a> to run this Docker Swarm cluster (on your laptop, if so desired). You can find all these files in the &ldquo;docker-swarm&rdquo; folder of <a href="https://github.com/scottslowe/learning-tools">my GitHub learning-tools repository</a>.</p>
<p>The Docker Swarm cluster I&rsquo;m going to show you how to build has 3 major components:</p>
<ul>
<li>A cluster of systems running Consul. In this case, Consul serves a dual purpose. First, it&rsquo;s used as the discovery service for the Docker Swarm cluster itself. Second, it provides service registration and service discovery functionality for the Docker containers launched on the Swarm cluster.</li>
<li>A set of hosts running the Docker daemon (version 1.4.0 or higher, as required by Swarm). In this case, I&rsquo;m using <a href="https://coreos.com">CoreOS</a> Stable 557.2.0, which has Docker 1.4.1.</li>
<li>A few containers running on the CoreOS hosts: a Consul client, <a href="https://github.com/gliderlabs/registrator">Registrator</a> (for dynamically registering and unregistering Docker containers), and Swarm.</li>
</ul>
<p>Ready? Let&rsquo;s get started!</p>
<h2 id="setting-up-consul">Setting up Consul</h2>
<p>If you&rsquo;re unfamiliar with Consul, I recommend having a look at <a href="/2015/02/06/quick-intro-to-consul/">my quick introduction to Consul</a>. Since that post provides an overview of getting Consul installed (which is really simple), I&rsquo;ll focus here on bootstrapping the Consul cluster. I&rsquo;m not running the Consul cluster as containers on the CoreOS systems (which works fine) in order to sidestep the issue of dealing with the CoreOS automatic updates (and subsequent reboots) and to simplify the overall environment a bit.</p>
<p>I&rsquo;m using two pieces to handle bootstrapping the Consul cluster. First, I have a Consul configuration file that provides the necessary configuration details to Consul. Here&rsquo;s the JSON-formatting Consul configuration file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;bootstrap_expect&#34;</span>: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;server&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;data_dir&#34;</span>: <span style="color:#e6db74">&#34;/var/consul&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;log_level&#34;</span>: <span style="color:#e6db74">&#34;INFO&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;enable_syslog&#34;</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;retry_join&#34;</span>: [<span style="color:#e6db74">&#34;192.168.1.101&#34;</span>, <span style="color:#e6db74">&#34;192.168.1.102&#34;</span>, <span style="color:#e6db74">&#34;192.168.1.103&#34;</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;client_addr&#34;</span>: <span style="color:#e6db74">&#34;0.0.0.0&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The Consul web site provides documentation for all these parameters, but let&rsquo;s walk through this real quick:</p>
<ul>
<li>The <code>bootstrap_expect</code> line tells Consul to form a cluster when at least 3 nodes are present. This allows us to start Consul nodes independently, but none of them will start working as expected until 3 are online and communicating.</li>
<li>The <code>server</code> line instructs the Consul agent (running as a daemon) to operate as a server.</li>
<li>The <code>data_dir</code> directory instructs Consul to store its working files in <code>/var/consul</code>. Note you&rsquo;ll need to create that directory (and assign appropriate permissions).</li>
<li>The <code>log_level</code> and <code>enable_syslog</code> lines configure logging (which, by default, will go to <code>/var/log/consul.log</code>).</li>
<li>The <code>retry_join</code> line provides a list of addresses for other expected members of the Consul cluster. I use the <code>retry_join</code> line instead of <code>join</code> so that we can independently start the Consul nodes. You&rsquo;ll want/need to edit this line to use IP addresses that are applicable/correct for your environment.</li>
<li>Finally, the <code>client_addr</code> line tells Consul to listen on all interfaces (not just loopback, which is the default).</li>
</ul>
<p>You can store this anywhere you&rsquo;d like, but if you want to use the scripts and such that I&rsquo;ve created, put this configuration file in <code>/etc/consul.d/server</code> as a file named <code>config.json</code>.</p>
<p>Next, I have an Upstart script to start and run the Consul agent as a daemon using the above configuration file. Here&rsquo;s the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>description &#34;Consul server process&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start on runlevel [2345]
</span></span><span style="display:flex;"><span>stop on runlevel [!2345]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>respawn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>script
</span></span><span style="display:flex;"><span>  if [ -f &#34;/etc/service/consul&#34; ]; then
</span></span><span style="display:flex;"><span>    . /etc/service/consul
</span></span><span style="display:flex;"><span>  fi
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export GOMAXPROCS=`nproc`
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exec /usr/local/bin/consul agent \
</span></span><span style="display:flex;"><span>  -config-dir=&#34;/etc/consul.d/server&#34; \
</span></span><span style="display:flex;"><span>  ${CONSUL_FLAGS} \
</span></span><span style="display:flex;"><span>  &gt;&gt;/var/log/consul.log 2&gt;&amp;1
</span></span><span style="display:flex;"><span>end script
</span></span></code></pre></div><p>You can see that this script assumes the Consul binary is in <code>/usr/local/bin</code>; if you store it elsewhere, be sure to adjust this script accordingly. Store this file as <code>consul.conf</code> in <code>/etc/init</code>; then you can use these commands to start and stop Consul, respectively:</p>
<pre><code>sudo service consul start
sudo service consul stop
</code></pre>
<p>Ideally, you&rsquo;ll also want to create a dedicated user for Consul, and assign ownership/permissions on the <code>/etc/consul.d</code> and <code>/var/consul</code> directories to that user.</p>
<p>Setting up the Consul cluster therefore looks something like this:</p>
<ol>
<li>Get an Ubuntu 14.04 system (or possibly earlier versions) up and running.</li>
<li>Install the Consul binary to <code>/usr/local/bin</code>.</li>
<li>Create the Consul user.</li>
<li>Create the <code>/etc/consul.d/server</code> and <code>/var/consul</code> directories, and assign ownership/permission for those directories to the Consul user.</li>
<li>Put the configuration file listed above onto the Ubuntu system as <code>config.json</code> in the <code>/etc/consul.d/server</code> directory.</li>
<li>Put the Upstart script listed above onto the Ubuntu system as <code>consul.conf</code> in the <code>/etc/init</code> directory.</li>
<li>Start the Consul daemon using <code>sudo service consul start</code>.</li>
<li>Repeat steps 1-7 for two more systems to establish the minimum of three systems running Consul.</li>
</ol>
<p>Once your Consul cluster is up and running (you can test this by running <code>consul members</code>; you should see a list of three systems in the cluster), you&rsquo;re ready to move on to setting up the Swarm cluster.</p>
<h2 id="setting-up-the-swarm-cluster">Setting up the Swarm Cluster</h2>
<p>I won&rsquo;t go into any detail here on setting up some systems to run the Docker Engine (daemon); I&rsquo;ll leave that as an exercise for the reader. Since Consul will serve as the back-end discovery service for the Swarm cluster I&rsquo;m not immediately aware of any minimum number of Docker Engine nodes, but let&rsquo;s assume you&rsquo;ll need to start at three. If you want to use CoreOS, be sure to use a version of CoreOS that containers Docker &gt;= 1.4.0. CoreOS Stable 557.2.0 includes Docker 1.4.1, and therefore will work with Docker Swarm.</p>
<p>You&rsquo;ll also need to ensure that Docker Engine on each node is configured to listen on a network port. I&rsquo;ll assume you&rsquo;ve configured Docker Engine to listen on TCP 2375, which is the official IANA registered port for Docker (TCP 2376 if you&rsquo;re using TLS).</p>
<p>Setting up the Swarm cluster is pretty straightforward. On each Docker Engine node (CoreOS in my example), launch a Docker container with the following command line:</p>
<pre><code>docker run -d swarm join --addr=&lt;node IP address&gt;:2375 consul://&lt;IP address of Consul server in cluster&gt;:8500/swarm
</code></pre>
<p>Substitute the IP address of the Docker Engine node for the <code>--addr</code> parameter, and substitute the IP address of a member of the Consul cluster for the <code>consul://</code> discovery URL. Therefore, if your Docker Engine node was at 192.168.1.104 and one of the Consul servers was at 192.168.1.101, the command would look like this:</p>
<pre><code>docker run -d swarm join --addr=192.168.1.104:2375 consul://192.168.1.101:8500/swarm
</code></pre>
<p>Note that the &ldquo;/swarm&rdquo; on the end of the discovery URL is an arbitrary path; just be sure to use the same value everywhere in the Swarm cluster.</p>
<p>Repeat this process on every node that should be a part of the Docker Swarm cluster.</p>
<p>Finally, on a system running Docker Engine (it can be a separate system or a system that is part of the cluster), run a Docker container that will enable managing the Swarm cluster:</p>
<pre><code>docker run -d -p &lt;Swarm port&gt;:2375 swarm manage consul://&lt;&lt;IP address of Consul server in cluster&gt;:8500/swarm
</code></pre>
<p>Replace <code>&lt;Swarm port&gt;</code> with a port number, and specify the IP address of one of the servers in the Consul cluster. If you used a path other than &ldquo;/swarm&rdquo;, be sure to use the same path here. This command sets up an endpoint against which you&rsquo;ll run Docker commands&mdash;only in this case those Docker commands will be executed against the entire cluster.</p>
<p>So, let&rsquo;s say you want to run an Nginx container named &ldquo;www&rdquo; somewhere on the Swarm cluster. Assuming that you used 8333 as the Swarm port when launching the Swarm manager and that the Swarm manager was running on a system with the IP address 192.168.1.104, you&rsquo;d do that with this command:</p>
<pre><code>docker -H tcp://192.168.1.104:8333 run -d --name www -p 80:80 nginx
</code></pre>
<p>If you wanted to see a list of the containers running across all the systems in the Swarm cluster, you&rsquo;d run this command:</p>
<pre><code>docker -H tcp://192.168.1.104:8333 ps
</code></pre>
<p>If you wanted to see information about the cluster, the nodes in the cluster, and the containers running across the cluster, you&rsquo;d run this command:</p>
<pre><code>docker -H tcp://192.168.1.104:8333 info
</code></pre>
<p>Of course, you could also set the <code>DOCKER_HOST</code> environment variable, and then you could skip the <code>-H tcp://...</code> portion of the commands above.</p>
<p>That&rsquo;s it! You&rsquo;ve just set up your own Docker Swarm cluster. But wait, there&rsquo;s more&hellip;</p>
<h2 id="setting-up-service-registration-and-discovery">Setting up Service Registration and Discovery</h2>
<p>Docker Swarm will take care of scheduling and running containers on Docker Engine nodes within the cluster, but how in the world does one connect to services running in those containers? How does one know which IP addresses and ports are in use? That&rsquo;s where service registration and service discovery come into play. Since Consul is already running in this environment, I&rsquo;ll leverage Consul to also provide service registration and service discovery functionality.</p>
<p>Adding this functionality to the existing Consul-backed Docker Swarm cluster is pretty straightforward. There are two pieces involved: running a Consul client container and running a Registrator container on each Docker Engine node in the Swarm cluster. The Registrator container monitors the Docker UNIX socket for events, and registers/de-registers containers and services upon start and stop. The Consul client receives the registration/de-registration events from Registrator and forwards them to the Consul cluster, where other systems can query to find and locate containers and services (even through DNS). Cool, eh?</p>
<p>To run a Consul client as a container on a Docker Engine node in the Swarm cluster, use this command (executed against the Docker Engine directly, not through Swarm):</p>
<pre><code>docker run -d -p 8300:8300 -p 8301:8301 -p 8301:8301/udp -p 8302:8302 -p 8302:8302/udp -p 8400:8400 -p 8500:8500 -p 8600:8600/udp --name &lt;container-name&gt; -h &lt;hostname&gt; progrium/consul -rejoin -advertise &lt;external IP address&gt; -join &lt;Consul server IP address&gt;
</code></pre>
<p>OK, that&rsquo;s a hefty command, so let&rsquo;s break it down:</p>
<ul>
<li>All the various <code>-p</code> parameters are exposing the necessary Consul ports for communication.</li>
<li>The specific container image you&rsquo;re using is <code>progrium/consul</code>, which is a Dockerized Consul agent.</li>
<li>Be sure to specify a unique value both for the container name (via <code>--name</code>) and a unique hostname (via the <code>-h</code> parameter).</li>
<li>The <code>-advertise</code> parameter needs to advertise the external IP address of the Docker Engine node, not the private IP address assigned to the container behind the Docker bridge.</li>
<li>Finally, the <code>-join</code> parameter should specify the IP address of one of the servers in the Consul cluster.</li>
</ul>
<p>After launching this container, you can verify that it is working as expected via two methods:</p>
<ol>
<li>Use the <code>docker logs</code> command to see the logs from the container and see that it is communicating with the Consul cluster.</li>
<li>Use the <code>consul members</code> command from one of the Consul servers to show that there is now a &ldquo;client&rdquo; node participating in Consul. (Client nodes forward requests to server nodes.)</li>
</ol>
<p>Almost done! Next, launch a Registrator container on each Docker Engine node (directly, not using Swarm) with this command:</p>
<pre><code>docker run -d --name &lt;container name&gt; -h &lt;hostname&gt; -v /var/run/docker.sock:/tmp/docker.sock progrium/registrator consul://&lt;Consul server IP address&gt;:8500
</code></pre>
<p>As with the Consul client container, be sure to use a unique container name and hostname, and substitute the IP address of one of the Consul servers in the <code>consul://</code> URL.</p>
<p>You can use <code>docker logs</code> to verify Registrator&rsquo;s operation; you should see a series of registration events in the output.</p>
<p>You can also query Consul directly to see if Registrator registered the services in Consul by using this command:</p>
<pre><code>curl http://&lt;Consul server IP address&gt;:8500/v1/catalog/services | python -m json.tool
</code></pre>
<p>You should see JSON output listing the services (unique TCP and UDP ports) from the containers across the Docker Swarm cluster. To get more information about a particular service, modify the previous command to include the service name. For example, if you&rsquo;d launched an Nginx container on the cluster the command would look like this:</p>
<pre><code>curl http://&lt;Consul server IP address&gt;:8500/v1/catalog/service/nginx-80 | python -m json.tool
</code></pre>
<p>That will provide JSON-formatted output that lists all the instances of this service across the cluster, the IP addresses and nodes associated with the service, and any metadata (which probably won&rsquo;t exist).</p>
<p>All set&mdash;you&rsquo;ve just built a Consul cluster, used Consul as the discovery service to back-end a Docker Swarm cluster, use Docker Swarm to launch a container, and then provided service registration and service discovery functionality via Consul and Registrator. Good job!</p>
<h2 id="additional-resources">Additional Resources</h2>
<p>You can find copies of all the scripts, configuration files, and a <code>Vagrantfile</code> to follow along using Vagrant in the &ldquo;docker-swarm&rdquo; folder of <a href="https://github.com/scottslowe/learning-tools">my GitHub &ldquo;learning-tools&rdquo; repository</a>.</p>


  <h3>Metadata and Navigation</h3>
  <span class="post-meta">
  <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/docker">Docker</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/linux">Linux</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/cli">CLI</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/vagrant">Vagrant</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/fusion">Fusion</a> <i class="fa fa-tag" aria-hidden="true"></i>&#160;<a href="/tags/virtualization">Virtualization</a> 

  <br />
  <i class="fa fa-arrow-circle-left" aria-hidden="true"></i> Previous Post: <a href="https://www.howellyang.com/2015/02/28/experimenting-docker-registrator-consul/">Experimenting with Docker, Registrator, and Consul</a>
  
  <br />
   <i class="fa fa-arrow-circle-right" aria-hidden="true"></i> Next Post: <a href="https://www.howellyang.com/2015/03/08/choosing-coreos-over-atomic/">Choosing CoreOS over Project Atomic</a>
  </span>

  <span class="post-sharing">
  <p>Be social and share this post!<br />

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.howellyang.com%2f2015%2f03%2f06%2frunning-own-docker-swarm-cluster%2f" title="Share on Facebook"><i class="fa fa-facebook-square fa-2x"></i></a>
  <a href="https://twitter.com/intent/tweet?url=https%3a%2f%2fwww.howellyang.com%2f2015%2f03%2f06%2frunning-own-docker-swarm-cluster%2f&text=Running%20a%20Small%20Docker%20Swarm%20Cluster" title="Share on Twitter"><i class="fa fa-twitter-square fa-2x"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2fwww.howellyang.com%2f2015%2f03%2f06%2frunning-own-docker-swarm-cluster%2f" title="Share on Google Plus"><i class="fa fa-google-plus-square fa-2x"></i></a></p>
  </span>
</div>

<div class="related">
  <h3>Related Posts</h3>
  <ul class="related-posts">
  <li><a href="/2015/02/05/vagrant-coreos-etcd-fleet-docker/">Using Vagrant with CoreOS, etcd, fleet, and Docker</a> <span class="post-date-list">59 May 5055</span></li><li><a href="/2015/02/10/using-docker-with-vagrant/">Using Docker with Vagrant</a> <span class="post-date-list">109 May 101010</span></li><li><a href="/2015/02/11/multi-container-docker-yaml-vagrant/">Multi-Container Docker with YAML and Vagrant</a> <span class="post-date-list">119 May 111111</span></li>
  </ul>
</div>      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>
